<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Providing feedback &mdash; catalight 0.0.1 documentation</title>
      <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
    <link rel="shortcut icon" href="_static/catalight_logo1_thick.svg"/>
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Examples" href="examples.html" />
    <link rel="prev" title="Laser calibration" href="auxiliary_tools.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            catalight
              <img src="_static/catalight_header_g_whitetext.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Introduction:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="intro.html">Welcome to Catalight!</a></li>
<li class="toctree-l1"><a class="reference internal" href="intro.html#installation-instructions">Installation instructions:</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html">How it works</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html#usage">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html#equipment-specific-guides">Equipment specific guides</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html#data-analysis">Data analysis</a></li>
<li class="toctree-l1"><a class="reference internal" href="user_guide.html#auxiliary-tools">Auxiliary tools</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development Guide:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Providing feedback</a></li>
<li class="toctree-l1"><a class="reference internal" href="#developing-equipment-drivers">Developing equipment drivers</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#my-equipment-doesn-t-have-a-python-api">My equipment doesn’t have a Python API</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#creating-new-experiment-types">Creating new experiment types</a></li>
<li class="toctree-l1"><a class="reference internal" href="#making-changes-to-the-gui">Making changes to the GUI</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#function">Function</a></li>
<li class="toctree-l2"><a class="reference internal" href="#style">Style</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="#areas-for-future-development">Areas for future development</a></li>
<li class="toctree-l1"><a class="reference internal" href="#writing-documentation">Writing documentation</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Examples:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="api.html">API</a></li>
<li class="toctree-l1"><a class="reference internal" href="tests.html">Tests</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">catalight</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Providing feedback</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/developer_guide.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="providing-feedback">
<h1>Providing feedback<a class="headerlink" href="#providing-feedback" title="Permalink to this heading"></a></h1>
<p class="linemarker linemarker-3">The development of v1 of catalight took over a year. While that was a tremendous learning opportunity, the length of time means there are undoubtedly details left out from this documentation that may be crucial for first time users. Please feel free to reach out to the authors with questions, and we strongly encourage feedback on the documentation. A lot of work went into developing this project, and we want other labs to benefit from this effort and do more productive research! The original authors self learned Python while developing this project. There very well may be aspects of the project that could be improved, so please reach out of fork our Github project if you see any other areas for improvement. Your questions/feedback are not only welcome, but encouraged!</p>
</section>
<section id="developing-equipment-drivers">
<h1>Developing equipment drivers<a class="headerlink" href="#developing-equipment-drivers" title="Permalink to this heading"></a></h1>
<p class="linemarker linemarker-7">catalight was built with modularity in mind. We do not want to make a code project that only allows the automation of a single lab setup! That being said, its not feasible to create a universal code package that is both user friendly and compatible with all equipment immediatly. Drivers for specific pieces of equipment need to be written for users hoping to use other equipment types. Our <a class="reference internal" href="equipment_guides.html"><span class="doc">Equipment Specific Guides</span></a> section is meant to serve as both instructions for users attempting to connect the exact hardware we utilize in our lab and to serve as examples for users developing new equipment drivers.</p>
<p class="linemarker linemarker-9">We ask that users developing new hardware (a) fork our Github to eventually merge improvements to the main project, (b) provide manuals for equipment within the catalight/equipment/”specific_equipment_folder” directory for the new piece of equipment developed, (c) write a <a class="reference internal" href="equipment_guides.html"><span class="doc">Equipment Specific Guides</span></a> to help other users utilize your code, and (d) write your specific driver utilizing the same function names as comparable equipment that has already been developed (see <a class="reference internal" href="#future"><span class="std std-ref">Areas for future development</span></a> for more thoughts on how abstract classes could be created to aid this process).</p>
<p class="linemarker linemarker-11">An excellent example of a flexible automated lab design can be found in the <a class="reference external" href="https://lightlab.readthedocs.io/en/development/index.html">LightLab</a> package. catalight was developped by novice programmers to be (a) more specific in scope than LightLab and (b) utilize existing Python APIs in place of developing VISA-based drivers for equipment. The trade off is that catalight is a less flexible codebase that we hope is more user friendly for researchers working on photocatalysis experiment specifically, where as LightLab is a flexible project that seems best suited for optical characterization labs.</p>
<section id="my-equipment-doesn-t-have-a-python-api">
<h2>My equipment doesn’t have a Python API<a class="headerlink" href="#my-equipment-doesn-t-have-a-python-api" title="Permalink to this heading"></a></h2>
<p class="linemarker linemarker-15">This is a tough situation and some additional programming will be required! Two approaches for this situation include (1) connecting with the equipment by interfacing with the providers software system and (2) writing low level or VISA communication interfaces, for example, by using pySerial/pyVISA.</p>
<p class="linemarker linemarker-17">Our SRI GC connection is an example of approach 1. There is no Python interface supported by the equipment developer or by found on PyPi or Github (that we could find). Fortunately, the equipment developer does supply a programing interface to thier control software, but it is not written specifically for Python. We were able to connect to this using the “<a class="reference external" href="https://dotnet.microsoft.com/en-us/learn/dotnet/what-is-dotnet">.NET infrastructure</a>” which is a way to reuse code across multiple languages via something called “<a class="reference external" href="https://learn.microsoft.com/en-us/dotnet/standard/clr">Common Language Runtime</a>” and <a class="reference external" href="https://pypi.org/project/pythonnet/">python.NET</a>. If you’ve never heard of this, neither did we! Thankfully, this can look pretty simple in practice. See our <a class="reference internal" href="equipment_guides.html#sri-gc-doc"><span class="std std-ref">SRI GC</span></a> specific guide for more details on how this works.</p>
<p class="linemarker linemarker-19">If the producer of your equipment does not provide a Python-specific programming interface to your equipment or its software (if it has software), you may need to interface with your equipment via some communication protocol, like VISA. Some examples of this includes The <a class="reference external" href="https://pywatlow.readthedocs.io/en/latest/readme.html">pywatlow package</a> and Brendan Sweeny’s <a class="reference external" href="http://brendansweeny.com/posts/watlow">write up</a> on how he created it, the <a class="reference external" href="https://github.com/numat/alicat">alicat package</a> which uses pySerial to control MFCs, and the <a class="reference external" href="https://lightlab.readthedocs.io/en/development/index.html">LightLab</a> project which generalizes the development of VISA connections to lab equipment. Often, equipment without software or an existing API will have a programmer manual describing how to use serial/GPIB/VISA communication commands.</p>
<p class="linemarker linemarker-21">Ideally, users that need to develop their own communication interfaces through some read/write commands via pySerial, pyVISA, and the like can write their python driver in a seperate package, publish it, and import it into the catalight package. It is much easier for users to use tools with more human readable commands like alicat.MassFlowController.set_flow() wrapping over the signals communication. Ease of use is exactly why we choose to use packages like alicat and pywatlow in the first place!!</p>
</section>
</section>
<section id="creating-new-experiment-types">
<h1>Creating new experiment types<a class="headerlink" href="#creating-new-experiment-types" title="Permalink to this heading"></a></h1>
<p class="linemarker linemarker-25">Coming soon</p>
</section>
<section id="making-changes-to-the-gui">
<h1>Making changes to the GUI<a class="headerlink" href="#making-changes-to-the-gui" title="Permalink to this heading"></a></h1>
<section id="function">
<h2>Function<a class="headerlink" href="#function" title="Permalink to this heading"></a></h2>
<p class="linemarker linemarker-31">To create new static widget, we recommend using the QtDesigner application and opening the <code class="file docutils literal notranslate"><span class="pre">catalight.gui_components.reactorUI.ui</span></code> file. Any custom widgets added to the GUI can be inserted to the <cite>catalight.gui_components</cite> folder and promoted within QtDesigner. In the current state, all static widgets were created in this way when used within <a class="reference internal" href="_autosummary/catalight.catalight_GUI.html#module-catalight.catalight_GUI" title="catalight.catalight_GUI"><code class="xref py py-mod docutils literal notranslate"><span class="pre">catalight.catalight_GUI</span></code></a> and the code inside of this module connection all of the functionality of the GUI window and its components. Remember, the main purpose of the GUI is to help the user create experiment objects and “run a study”. Experimental functionality should be added to the <a class="reference internal" href="_autosummary/catalight.equipment.experiment_control.Experiment.html#catalight.equipment.experiment_control.Experiment" title="catalight.equipment.experiment_control.Experiment"><code class="xref py py-class docutils literal notranslate"><span class="pre">Experiment</span></code></a> class. New widgets should help fill attributes of the Experiment class or other classes that need to be developed in the future. A second, but major function of the GUI is to directly control hardware. Future development should allow users to choose and utilize any equipment within the GUI.</p>
</section>
<section id="style">
<h2>Style<a class="headerlink" href="#style" title="Permalink to this heading"></a></h2>
<p class="linemarker linemarker-35"><code class="xref py py-mod docutils literal notranslate"><span class="pre">catalight.gui_components.style_guide</span></code> is a subpackage accessible when catalight is downloaded as a repository from the GitHub page. Within this folder is two image files and a folder containing QSS templates. The “icon.svg” and “drawing.svg” files can be replaced with the file of your choice, provided your match the filename exactly. This should replace the catalight icon and D-Lab logos within the GUI directly, without any code changes. To use alternate file types, you’ll need to utilize QT Designer (or edit the ui file - not recommended) to change the image resource path.
The QSS sheet was downloaded an lightly modified from <a class="reference external" href="https://qss-stock.devsecstudio.com/templates.php">the QSS Stock website</a>. You can edit this file for wide-spread style changes to the GUI appearance, or enter your own QSS style sheet and insert it to the GUI by editting the path inside the <a class="reference internal" href="_autosummary/catalight.catalight_GUI.setup_style.html#catalight.catalight_GUI.setup_style" title="catalight.catalight_GUI.setup_style"><code class="xref py py-func docutils literal notranslate"><span class="pre">catalight.catalight_GUI.setup_style()</span></code></a> function.</p>
</section>
</section>
<section id="areas-for-future-development">
<span id="future"></span><h1>Areas for future development<a class="headerlink" href="#areas-for-future-development" title="Permalink to this heading"></a></h1>
<p class="linemarker linemarker-43">Design is an iterative process. The catalight project has already been updated several times going into the deployment of v1.0.0, but there is always room for improvement. Below is a laundry list of improvements that can be added to future versions of the package.</p>
<p class="linemarker linemarker-45">The current iteration of the system has been designed with modularity in mind, but additional improvements could be made to enable more seamless use by a variety of groups with different hardware configurations. This will become increasingly important as users develop their own equipment classes.</p>
<ul class="simple">
<li><p class="linemarker linemarker-47">Better methods need to be developped to <strong>allow users to configure specific hardware</strong> with minimal coding while maximizing compatibility with the rest of the package.</p>
<ul>
<li><p class="linemarker linemarker-49">For example, an abstract “GasSystem” class could be created with standardized class method names compatible with the rest of the package, then a specific “AlicatGasSystem” class can be initialized that subclasses the abstract class and decorates the class methods to make them compatible with the specific hardware used by a particular lab. In otherwords, the methods of every gas sytem should behave identically on the surface, while the actual implementation should change for each specific hardware setup. AlicatGasSystem.set_flow() needs to behave the same as a hypothetical BronkhorstGasSystem.set_flow()</p></li>
<li><p class="linemarker linemarker-51">This would ideally be managed in a single location, such as a configuration file, that a new user could edit once in order to make the system compatible with their hardware. Ideally no other code components would need to be edited. This configuration file could allow the user to change between “AlicatGasSystem” or “BronkhorstGasSystem”. If class abstraction is implemented correctly, the rest the code package will continue working as intended.</p></li>
<li><p class="linemarker linemarker-53">The <a class="reference external" href="https://lightlab.readthedocs.io/en/development/index.html">LightLab</a> package is an excellent example of flexible lab configuration and could be a very helpful reference for development in this area. In particular, future development should look into their implementation of <a class="reference external" href="https://lightlab.readthedocs.io/en/development/API/lightlab.laboratory.instruments.interfaces.html">“essentialMethods”</a> attribute for abstract drivers and type checking in their <a class="reference external" href="https://github.com/lightwave-lab/lightlab/blob/development/lightlab/equipment/visa_bases/visa_driver.py">DriverMeta</a> class. Their tutorial on <a class="reference external" href="https://lightlab.readthedocs.io/en/development/_static/tutorials/drivers/drivers.html">creating instrument drivers</a> is also a great reference.</p></li>
</ul>
</li>
<li><p class="linemarker linemarker-55"><strong>The Gas_System class needs to support a flexible number of MFCs.</strong> The gas_system class and the related GUI components are currently configured to work with a specific number of mass flow controllers. This could easily be amended by utilizing loops and list for accessing MFC data and controls. For example, the MFC class currently has attributes self.mfc_a, self.mfc_b, etc. This should be replaced by self.mfc_list which contains a list of all mfcs used by the system, allowing flexibility for different system configurations. Ideally this can be managed by a file outside the gas_system class. This also needs to be updated within the GUI code, which currently generates MFC components using QtDesigner. This would need to be done programmatically for flexibility.</p></li>
<li><p class="linemarker linemarker-57">The data analysis sub-package was initially designed with only gas chromatography data in mind. The original authors intend to <strong>implement FTIR data and support for multiple GC detectors</strong> in the near future, but additional consideration for adaptability with other data types needs to be considered to expand usability.</p></li>
<li><p class="linemarker linemarker-59"><strong>Calibration files need to be able to handle components logged on multiple detectors.</strong> This could either be handled by individual calibration files for each detector or by string handling to inteligently interpret slashes, for example</p></li>
<li><p class="linemarker linemarker-61"><strong>The toolbar in the GUI needs to displays realistic values from the actual data shown.</strong> The main GUI creates a matplotlib figure with an interactive toolbar, but the x, y coordinates are set for the underlying sub-plot instead of the two front most half figures.</p></li>
<li><p class="linemarker linemarker-63"><strong>Unit testing</strong> will be an important feature for implementing pull requests on GitHub if new users try contributing to the project. These will be implemented in the future.</p></li>
<li><p class="linemarker linemarker-64"><strong>Formalized error reporting</strong> needs to be handled.</p></li>
<li><p class="linemarker linemarker-65"><strong>Wavelength sweep experiments</strong> will be implemented when NKT support is (soon)</p></li>
<li><p class="linemarker linemarker-66"><strong>Stability test experiments should be implemented more clearly.</strong> The current implementation of stability test is clunky. It looks confusing in the GUI and doesn’t have a dedicated time ind_var. Fixing will require some refactoring.</p></li>
<li><p class="linemarker linemarker-67"><strong>Add plot integration option to chromatogram_scanner_gui</strong></p></li>
<li><p class="linemarker linemarker-68"><strong>Add option to lock scale on chromatogram_scanner_gui</strong>, possibly by getting max value of all files</p></li>
<li><p class="linemarker linemarker-69"><strong>Save control file used in expt_log.txt</strong></p></li>
<li><p class="linemarker linemarker-70"><strong>Print console output to a new study_log.txt file</strong></p></li>
<li><p class="linemarker linemarker-71"><strong>Make sure close process occurs if GUI crashes</strong>. The GUI occassionally crashes in what seems to be a computer fault, emitting no error messages. When this happens, the close event protocol is not run and the equipment is not shutdown. There must be some way to detect this events and shutdown the hardware still.</p></li>
<li><p class="linemarker linemarker-72"><strong>A tool can be built to scan experiment results</strong>. A lot of data can be generated when experiments are run and analyzed automatically. Parsing through many folders of experiments and pulling out graphs is a hassle. A scanner gui can be built like the chromatogram_scanner_gui to scan through X and S plots.</p></li>
<li><p class="linemarker linemarker-73"><strong>Add get_user_inputs function to run_diode_calibration</strong></p></li>
<li><p class="linemarker linemarker-74"><strong>Generalize run_diode_calibration</strong> to take in any laser/power meter</p></li>
</ul>
</section>
<section id="writing-documentation">
<h1>Writing documentation<a class="headerlink" href="#writing-documentation" title="Permalink to this heading"></a></h1>
<p class="linemarker linemarker-78">Writing documentation is important! You can use the <a class="reference external" href="https://docs.readthedocs.io/en/stable/tutorial/index.html">ReadtheDocs tutorial</a> to get familiar with how writing documentation works. We used sphinx to build our API automatically from docstrings, and mostly utilized numpy style docstrings. Especially since this package is written by beginners for beginners, its important to note that docstrings require a specific format to be read by automatic documentation tools!!! We didn’t appreciate this when starting, and it lead to many hours of rewriting docstrings. If you aren’t familiar with docstring (typically enclosed in triple quote ‘’’ under functions/classes/attributes), you should think of them as instruction on how to use a given function, class, or method. They aren’t really a step by step of how a piece of code works, but should contain information on what the code takes in, performs, and returns. The end-user shouldn’t need to know exactly how the code works! Of course, you should still comment you source code, too! Many science users are probably most familiar with “documentation” in the form of writing comments that the end-user will use as instructions. Likely, you are used to sending a collaborator a .py file and them editting it directly with user inputs and changes. This isn’t the “right way” to distribute code. You want to write functions and documentation such that the user doesn’t need to know anything about how it works, like when you import numpy for example. The end user may never see you comments and code, only call your function using its docstring!</p>
<p class="linemarker linemarker-80">If you write proper docstrings, the documentation of your code will be automated. This process is done using a tool called “sphinx” which is apparently the standard for documenting Python code. Though it is automated, it is not that intuitive. It is normal to experience many warning and can be difficult to find help resources. Ideally, this process won’t be necessary for other developers as we’ve already handled most of the configuring. The documentation writer should follow the spinx getting started tutorial to get basic familiarity with the process, but you should only need to run the “make clean” and “make html” commands from within catalight/docs once you’ve installed sphinx (a requirement for the catalight package anyway).</p>
<ol class="arabic simple">
<li><p class="linemarker linemarker-82"><a class="reference external" href="https://stackoverflow.com/questions/53099934/sphinx-apidoc-vs-autosummary">Using Sphinx’s autosummary tool vs sphinx-apidoc provides cleaner documentation</a></p></li>
<li><p class="linemarker linemarker-83"><a class="reference external" href="https://romanvm.pythonanywhere.com/post/autodocumenting-your-python-code-sphinx-part-ii-6/">More information on autosummary vs sphinx-apidoc</a></p></li>
<li><p class="linemarker linemarker-84"><a class="reference external" href="https://stackoverflow.com/questions/48074094/use-sphinx-autosummary-recursively-to-generate-api-documentation">autosummary isn’t a complete solution. Custom .rst templates are needed</a></p></li>
<li><p class="linemarker linemarker-85"><a class="reference external" href="https://stackoverflow.com/questions/43983799/how-to-avoid-inherited-members-using-autosummary-and-custom-templates">Inherited members needed to be removed in the .rst class template so objects inheriting QT objects weren’t too many lines</a></p></li>
</ol>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="auxiliary_tools.html" class="btn btn-neutral float-left" title="Laser calibration" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="examples.html" class="btn btn-neutral float-right" title="Examples" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022, Briley Bourgeois, Claire Carlin.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>